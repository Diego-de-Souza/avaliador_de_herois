name: Deploy Frontend to AWS

on:
  # OpÃ§Ã£o 1: Deploy automÃ¡tico apenas na branch main/master
  push:
    branches:
      - main
      - master
  
  # OpÃ§Ã£o 2: Deploy em qualquer branch (descomente para ativar)
  # push:
  #   branches:
  #     - '*'  # Qualquer branch
  
  # OpÃ§Ã£o 3: Deploy apenas manual (descomente para ativar)
  # workflow_dispatch:
  
  # OpÃ§Ã£o 4: Deploy quando criar uma tag de release (descomente para ativar)
  # release:
  #   types: [published]

env:
  AWS_REGION: us-east-1
  FRONTEND_HOST: ${{ vars.FRONTEND_HOST }}
  SSH_HOST: ${{ vars.SSH_HOST || vars.FRONTEND_HOST }}
  SSH_USER: ec2-user
  APP_DIR: /var/www/app
  SSH_PORT: ${{ vars.SSH_PORT || '22' }}
  SSH_TIMEOUT: 30

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Validate required secrets and variables
        run: |
          if [ -z "${{ vars.FRONTEND_HOST }}" ]; then
            echo "Error: FRONTEND_HOST variable is not set"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "Error: SSH_PRIVATE_KEY secret is not set"
            exit 1
          fi
          echo "All required secrets and variables are set"
          echo "FRONTEND_HOST: ${{ vars.FRONTEND_HOST }}"
          echo "SSH_HOST: ${{ env.SSH_HOST }} (for SSH connection)"
          echo "SSH_PORT: ${{ env.SSH_PORT }}"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Run unit tests
        run: npm run test:ci
        continue-on-error: false  # Falha o deploy se testes falharem
        env:
          CI: true
          # VariÃ¡veis de ambiente para o mock do environment nos testes
          API_URL: ${{ vars.API_URL || 'http://localhost:3020/api' }}
          ID_CLIENTE_GOOGLE: ${{ vars.ID_CLIENTE_GOOGLE || '' }}
          SECRET_KEY_GOOGLE: ${{ secrets.SECRET_KEY_GOOGLE || '' }}
          STRIPE_PUBLIC_KEY: ${{ vars.STRIPE_PUBLIC_KEY || '' }}
          ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY || '' }}

      - name: Build application
        # Angular build com variÃ¡veis de ambiente
        run: npm run build
        env:
          NODE_ENV: production
          # VariÃ¡veis de ambiente necessÃ¡rias para o prebuild (scripts/generate-env.js)
          API_URL: ${{ vars.API_URL }}
          ID_CLIENTE_GOOGLE: ${{ vars.ID_CLIENTE_GOOGLE }}
          SECRET_KEY_GOOGLE: ${{ secrets.SECRET_KEY_GOOGLE }}
          STRIPE_PUBLIC_KEY: ${{ vars.STRIPE_PUBLIC_KEY }}
          ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Configurar opÃ§Ãµes SSH padrÃ£o
          # Usa SSH_HOST (pode ser IP ou subdomÃ­nio sem Cloudflare) para conexÃ£o SSH
          # mas mantÃ©m o alias do FRONTEND_HOST para facilitar o uso
          cat > ~/.ssh/config << EOF
          Host ${{ env.FRONTEND_HOST }}
            HostName ${{ env.SSH_HOST }}
            Port ${{ env.SSH_PORT }}
            User ${{ env.SSH_USER }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ConnectTimeout ${{ env.SSH_TIMEOUT }}
            ServerAliveInterval 60
            ServerAliveCountMax 3
          EOF
          chmod 600 ~/.ssh/config
          
          # Teste de conectividade bÃ¡sico usando timeout (disponÃ­vel no Ubuntu)
          echo "Testing connection to ${{ env.SSH_HOST }}:${{ env.SSH_PORT }}..."
          echo "Running connectivity test..."
          if timeout 10 bash -c "cat < /dev/null > /dev/tcp/${{ env.SSH_HOST }}/${{ env.SSH_PORT }}" 2>/dev/null; then
            echo "âœ… Port ${{ env.SSH_PORT }} is open and reachable"
          else
            echo "âŒ Port ${{ env.SSH_PORT }} test failed"
            echo "This usually means:"
            echo "  - The port is blocked by AWS Security Group"
            echo "  - The port is blocked by server firewall (ufw/iptables)"
            echo "  - The server is in a private subnet without public IP"
            echo "  - The SSH service is not running on the server"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Check AWS Security Group - allow inbound SSH (port 22) from 0.0.0.0/0 or GitHub Actions IPs"
            echo "2. Check server firewall: sudo ufw status (should allow port 22)"
            echo "3. Verify SSH service: sudo systemctl status sshd"
            echo "4. Check if server has public IP: curl ifconfig.me on the server"
          fi
          
          # Adiciona o host ao known_hosts usando o SSH_HOST real
          if [ -n "${{ env.SSH_HOST }}" ]; then
            ssh-keyscan -p ${{ env.SSH_PORT }} -H "${{ env.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not add host to known_hosts, but continuing..."
            chmod 644 ~/.ssh/known_hosts
          fi

      - name: Copy files to EC2
        run: |
          # Teste de conexÃ£o SSH antes de continuar
          echo "Testing SSH connection to ${{ env.SSH_HOST }}:${{ env.SSH_PORT }}..."
          
          # Verificar se o config existe e testar conexÃ£o
          SSH_CONFIG_PATH="$HOME/.ssh/config"
          SSH_CONNECTION_FAILED=false
          
          if [ -f "$SSH_CONFIG_PATH" ]; then
            echo "âœ… SSH config encontrado. Testando conexÃ£o..."
            ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} "echo 'SSH connection successful'" || SSH_CONNECTION_FAILED=true
          else
            echo "âš ï¸  SSH config nÃ£o encontrado, usando mÃ©todo alternativo..."
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "echo 'SSH connection successful'" || SSH_CONNECTION_FAILED=true
          fi
          
          if [ "$SSH_CONNECTION_FAILED" = true ]; then
            echo ""
            echo "âŒ ERROR: Cannot connect to ${{ env.SSH_HOST }}:${{ env.SSH_PORT }}"
            echo ""
            echo "The connection is timing out. This means the IP is reachable but port ${{ env.SSH_PORT }} is blocked or not responding."
            echo ""
            echo "ðŸ” Most likely causes:"
            echo ""
            echo "1. AWS Security Group blocking port 22"
            echo "   â†’ Go to EC2 Console â†’ Security Groups â†’ Select your instance's security group"
            echo "   â†’ Add Inbound Rule: Type=SSH, Port=22, Source=0.0.0.0/0 (or GitHub Actions IPs)"
            echo ""
            echo "2. Server firewall blocking port 22"
            echo "   â†’ SSH to the server (if you have another way) and run:"
            echo "     sudo ufw allow 22/tcp"
            echo "     sudo ufw reload"
            echo "   â†’ Or check iptables: sudo iptables -L -n"
            echo ""
            echo "3. SSH service not running"
            echo "   â†’ On the server, check: sudo systemctl status sshd"
            echo "   â†’ Start if needed: sudo systemctl start sshd"
            echo ""
            echo "4. Server in private subnet"
            echo "   â†’ If server is in a private subnet, you need a bastion host"
            echo "   â†’ Or assign a public IP to the instance"
            echo ""
            echo "5. Wrong SSH port"
            echo "   â†’ If SSH is on a different port, set SSH_PORT variable in GitHub"
            echo ""
            echo "Current configuration:"
            echo "  SSH_HOST: ${{ env.SSH_HOST }}"
            echo "  SSH_PORT: ${{ env.SSH_PORT }}"
            echo "  SSH_USER: ${{ env.SSH_USER }}"
            echo ""
            echo "ðŸ’¡ Quick test from your local machine:"
            echo "   ssh -v ${{ env.SSH_USER }}@${{ env.SSH_HOST }} -p ${{ env.SSH_PORT }}"
            exit 1
          fi
          
          echo "âœ… SSH connection successful!"
          
          # Instalar rsync no servidor se nÃ£o estiver instalado
          echo "Verificando se rsync estÃ¡ instalado no servidor..."
          INSTALL_RSYNC_SCRIPT="
          if ! command -v rsync &> /dev/null; then
            echo 'Instalando rsync...'
            if command -v yum &> /dev/null; then
              sudo yum install -y rsync
            elif command -v apt-get &> /dev/null; then
              sudo apt-get update && sudo apt-get install -y rsync
            else
              echo 'âŒ ERROR: NÃ£o foi possÃ­vel determinar o gerenciador de pacotes (yum/apt-get)'
              exit 1
            fi
          else
            echo 'âœ… rsync jÃ¡ estÃ¡ instalado'
          fi
          "
          
          if [ -f "$SSH_CONFIG_PATH" ]; then
            ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} "$INSTALL_RSYNC_SCRIPT"
          else
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "$INSTALL_RSYNC_SCRIPT"
          fi
          
          # Limpar diretÃ³rio antigo (opcional - mantÃ©m backup)
          echo "Criando backup do diretÃ³rio antigo..."
          if [ -f "$SSH_CONFIG_PATH" ]; then
            ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} \
              "sudo mkdir -p ${{ env.APP_DIR }}.backup && sudo cp -r ${{ env.APP_DIR }}/* ${{ env.APP_DIR }}.backup/ 2>/dev/null || true"
          else
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} \
              "sudo mkdir -p ${{ env.APP_DIR }}.backup && sudo cp -r ${{ env.APP_DIR }}/* ${{ env.APP_DIR }}.backup/ 2>/dev/null || true"
          fi
          
          # Verificar se a pasta dist existe antes de fazer rsync
          if [ ! -d "./dist/avaliador_de_herois" ]; then
            echo "âŒ ERROR: Pasta dist/avaliador_de_herois nÃ£o encontrada!"
            echo "O build pode ter falhado ou o outputPath estÃ¡ incorreto."
            exit 1
          fi
          
          # Verificar se hÃ¡ arquivos na pasta dist
          if [ -z "$(ls -A ./dist/avaliador_de_herois)" ]; then
            echo "âŒ ERROR: Pasta dist/avaliador_de_herois estÃ¡ vazia!"
            exit 1
          fi
          
          echo "âœ… Pasta dist encontrada com arquivos. Iniciando cÃ³pia..."
          
          # Preparar comando rsync com mÃ©todo que funcionou na conexÃ£o
          RSYNC_SUCCESS=false
          
          if [ -f "$SSH_CONFIG_PATH" ]; then
            echo "Usando SSH config para rsync..."
            if rsync -avz -e "ssh -F $SSH_CONFIG_PATH" \
              --delete \
              ./dist/avaliador_de_herois/ ${{ env.FRONTEND_HOST }}:/tmp/app/ 2>&1; then
              RSYNC_SUCCESS=true
            else
              RSYNC_EXIT_CODE=$?
              echo "âš ï¸  rsync com config falhou (exit code: $RSYNC_EXIT_CODE), tentando mÃ©todo alternativo..."
            fi
          fi
          
          # Se nÃ£o conseguiu com config, usar mÃ©todo alternativo
          if [ "$RSYNC_SUCCESS" = false ]; then
            echo "Usando mÃ©todo alternativo para rsync..."
            if rsync -avz -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }}" \
              --delete \
              ./dist/avaliador_de_herois/ ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/app/ 2>&1; then
              RSYNC_SUCCESS=true
            else
              RSYNC_EXIT_CODE=$?
              echo "âŒ rsync com mÃ©todo alternativo tambÃ©m falhou (exit code: $RSYNC_EXIT_CODE)"
            fi
          fi
          
          # Verificar se o rsync foi bem-sucedido
          if [ "$RSYNC_SUCCESS" = false ]; then
            echo "âŒ ERROR: rsync falhou ao copiar arquivos!"
            echo "Tentando mÃ©todo alternativo com tar + scp..."
            
            # MÃ©todo alternativo: criar tar e copiar via scp
            echo "Criando arquivo tar..."
            cd dist && tar czf avaliador_de_herois.tar.gz avaliador_de_herois/ && cd ..
            
            # Copiar via scp
            if [ -f "$SSH_CONFIG_PATH" ]; then
              scp -F "$SSH_CONFIG_PATH" ./dist/avaliador_de_herois.tar.gz ${{ env.FRONTEND_HOST }}:/tmp/app.tar.gz
            else
              scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P ${{ env.SSH_PORT }} ./dist/avaliador_de_herois.tar.gz ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/app.tar.gz
            fi
            
            if [ $? -eq 0 ]; then
              echo "âœ… Arquivo tar copiado com sucesso. Descompactando no servidor..."
              
              # Descompactar no servidor
              EXTRACT_SCRIPT="
              sudo mkdir -p /tmp/app
              sudo rm -rf /tmp/app/*
              cd /tmp && sudo tar xzf app.tar.gz -C /tmp/app --strip-components=1
              sudo rm -f /tmp/app.tar.gz
              echo 'âœ… Arquivos descompactados com sucesso'
              "
              
              if [ -f "$SSH_CONFIG_PATH" ]; then
                ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} "$EXTRACT_SCRIPT"
              else
                ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "$EXTRACT_SCRIPT"
              fi
              
              if [ $? -eq 0 ]; then
                echo "âœ… Arquivos copiados para /tmp/app no servidor (mÃ©todo alternativo)"
                rm -f ./dist/avaliador_de_herois.tar.gz
              else
                echo "âŒ ERROR: Falha ao descompactar arquivos no servidor!"
                exit 1
              fi
            else
              echo "âŒ ERROR: Falha ao copiar arquivo tar via scp!"
              exit 1
            fi
          else
            echo "âœ… Arquivos copiados para /tmp/app no servidor (via rsync)"
          fi

      - name: Move files and set permissions
        run: |
          # Determinar qual mÃ©todo SSH usar (o mesmo que funcionou no step anterior)
          SSH_CONFIG_PATH="$HOME/.ssh/config"
          
          # Script a ser executado no servidor
          SERVER_SCRIPT="
          # Verificar se /tmp/app existe e tem arquivos
          if [ ! -d \"/tmp/app\" ] || [ -z \"\$(ls -A /tmp/app)\" ]; then
            echo \"âŒ ERROR: /tmp/app nÃ£o existe ou estÃ¡ vazio!\"
            exit 1
          fi
          
          echo \"âœ… /tmp/app encontrado. Movendo arquivos para ${{ env.APP_DIR }}...\"
          
          # Criar diretÃ³rio se nÃ£o existir
          sudo mkdir -p ${{ env.APP_DIR }}
          
          # Limpar diretÃ³rio antigo
          sudo rm -rf ${{ env.APP_DIR }}/*
          
          # Mover arquivos
          sudo mv /tmp/app/* ${{ env.APP_DIR }}/
          
          # Verificar se a movimentaÃ§Ã£o foi bem-sucedida
          if [ -z \"\$(ls -A ${{ env.APP_DIR }})\" ]; then
            echo \"âŒ ERROR: Nenhum arquivo foi movido para ${{ env.APP_DIR }}!\"
            exit 1
          fi
          
            echo \"âœ… Arquivos movidos com sucesso. Configurando permissÃµes...\"
            
            # Configurar permissÃµes
            sudo chown -R nginx:nginx ${{ env.APP_DIR }}
            sudo chmod -R 755 ${{ env.APP_DIR }}
            
            echo \"âœ… PermissÃµes configuradas. Configurando Nginx...\"
            
            # Criar/atualizar configuraÃ§Ã£o do Nginx para Angular SPA
            # IMPORTANTE: Angular compila para browser/ dentro do outputPath
            NGINX_CONFIG=\"/etc/nginx/conf.d/heroesplatform.conf\"
            
            sudo tee \$NGINX_CONFIG > /dev/null << 'NGINX_EOF'
            server {
                listen 80;
                listen [::]:80;
                server_name heroesplatform.com.br www.heroesplatform.com.br;
                
                # DiretÃ³rio raiz - IMPORTANTE: Angular compila para browser/
                root ${{ env.APP_DIR }}/browser;
                index index.html;
                
                # Logs
                access_log /var/log/nginx/heroesplatform-access.log;
                error_log /var/log/nginx/heroesplatform-error.log;
                
                # Gzip compression
                gzip on;
                gzip_vary on;
                gzip_min_length 1024;
                gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json application/javascript;
                
                # Security headers
                add_header X-Frame-Options \"SAMEORIGIN\" always;
                add_header X-Content-Type-Options \"nosniff\" always;
                add_header X-XSS-Protection \"1; mode=block\" always;
                
                # ConfiguraÃ§Ã£o para SPA Angular - try_files tenta encontrar o arquivo, se nÃ£o encontrar, serve index.html
                location / {
                    try_files \$uri \$uri/ /index.html;
                    
                    # Cache para arquivos estÃ¡ticos
                    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
                        expires 1y;
                        add_header Cache-Control \"public, immutable\";
                    }
                }
                
                # Bloquear acesso a arquivos ocultos
                location ~ /\. {
                    deny all;
                    access_log off;
                    log_not_found off;
                }
            }
            NGINX_EOF
            
            echo \"âœ… ConfiguraÃ§Ã£o do Nginx criada. Testando configuraÃ§Ã£o...\"
            
            # Testar configuraÃ§Ã£o do Nginx
            if sudo nginx -t; then
              echo \"âœ… ConfiguraÃ§Ã£o do Nginx vÃ¡lida. Recarregando nginx...\"
              sudo systemctl reload nginx
              echo \"âœ… Nginx recarregado com sucesso!\"
            else
              echo \"âŒ ERRO: ConfiguraÃ§Ã£o do Nginx invÃ¡lida!\"
              sudo nginx -t
              exit 1
            fi
            
            echo \"âœ… Deploy concluÃ­do com sucesso!\"
          "
          
          # Executar script no servidor usando mÃ©todo que funcionou
          if [ -f "$SSH_CONFIG_PATH" ]; then
            ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} "$SERVER_SCRIPT"
          else
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "$SERVER_SCRIPT"
          fi

      - name: Health check
        run: |
          sleep 5
          curl -f http://${{ env.FRONTEND_HOST }} || exit 0  # NÃ£o falha se ainda nÃ£o estiver acessÃ­vel

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key
