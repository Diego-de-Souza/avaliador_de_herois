name: Deploy Frontend to AWS

on:
  # Op√ß√£o 1: Deploy autom√°tico apenas na branch main/master
  push:
    branches:
      - main
      - master
  
  # Op√ß√£o 2: Deploy em qualquer branch (descomente para ativar)
  # push:
  #   branches:
  #     - '*'  # Qualquer branch
  
  # Op√ß√£o 3: Deploy apenas manual (descomente para ativar)
  # workflow_dispatch:
  
  # Op√ß√£o 4: Deploy quando criar uma tag de release (descomente para ativar)
  # release:
  #   types: [published]

env:
  AWS_REGION: us-east-1
  FRONTEND_HOST: ${{ vars.FRONTEND_HOST }}
  SSH_HOST: ${{ vars.SSH_HOST || vars.FRONTEND_HOST }}
  SSH_USER: ec2-user
  APP_DIR: /var/www/app
  SSH_PORT: ${{ vars.SSH_PORT || '22' }}
  SSH_TIMEOUT: 30

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Validate required secrets and variables
        run: |
          if [ -z "${{ vars.FRONTEND_HOST }}" ]; then
            echo "Error: FRONTEND_HOST variable is not set"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "Error: SSH_PRIVATE_KEY secret is not set"
            exit 1
          fi
          echo "All required secrets and variables are set"
          echo "FRONTEND_HOST: ${{ vars.FRONTEND_HOST }}"
          echo "SSH_HOST: ${{ env.SSH_HOST }} (for SSH connection)"
          echo "SSH_PORT: ${{ env.SSH_PORT }}"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Run unit tests
        run: npm run test:ci
        continue-on-error: false  # Falha o deploy se testes falharem
        env:
          CI: true
          # Vari√°veis de ambiente para o mock do environment nos testes
          API_URL: ${{ secrets.API_URL || 'http://localhost:3020/api' }}
          ID_CLIENTE_GOOGLE: ${{ secrets.ID_CLIENTE_GOOGLE || '' }}
          SECRET_KEY_GOOGLE: ${{ secrets.SECRET_KEY_GOOGLE || '' }}
          STRIPE_PUBLIC_KEY: ${{ secrets.STRIPE_PUBLIC_KEY || '' }}
          ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY || '' }}

      - name: Build application
        # Angular build com vari√°veis de ambiente
        run: npm run build
        env:
          NODE_ENV: production
          # Vari√°veis de ambiente necess√°rias para o prebuild (scripts/generate-env.js)
          API_URL: ${{ secrets.API_URL }}
          ID_CLIENTE_GOOGLE: ${{ secrets.ID_CLIENTE_GOOGLE }}
          SECRET_KEY_GOOGLE: ${{ secrets.SECRET_KEY_GOOGLE }}
          STRIPE_PUBLIC_KEY: ${{ secrets.STRIPE_PUBLIC_KEY }}
          ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Configurar op√ß√µes SSH padr√£o
          # Usa SSH_HOST (pode ser IP ou subdom√≠nio sem Cloudflare) para conex√£o SSH
          # mas mant√©m o alias do FRONTEND_HOST para facilitar o uso
          cat > ~/.ssh/config << EOF
          Host ${{ env.FRONTEND_HOST }}
            HostName ${{ env.SSH_HOST }}
            Port ${{ env.SSH_PORT }}
            User ${{ env.SSH_USER }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ConnectTimeout ${{ env.SSH_TIMEOUT }}
            ServerAliveInterval 60
            ServerAliveCountMax 3
          EOF
          chmod 600 ~/.ssh/config
          
          # Teste de conectividade b√°sico usando timeout (dispon√≠vel no Ubuntu)
          echo "Testing connection to ${{ env.SSH_HOST }}:${{ env.SSH_PORT }}..."
          echo "Running connectivity test..."
          if timeout 10 bash -c "cat < /dev/null > /dev/tcp/${{ env.SSH_HOST }}/${{ env.SSH_PORT }}" 2>/dev/null; then
            echo "‚úÖ Port ${{ env.SSH_PORT }} is open and reachable"
          else
            echo "‚ùå Port ${{ env.SSH_PORT }} test failed"
            echo "This usually means:"
            echo "  - The port is blocked by AWS Security Group"
            echo "  - The port is blocked by server firewall (ufw/iptables)"
            echo "  - The server is in a private subnet without public IP"
            echo "  - The SSH service is not running on the server"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Check AWS Security Group - allow inbound SSH (port 22) from 0.0.0.0/0 or GitHub Actions IPs"
            echo "2. Check server firewall: sudo ufw status (should allow port 22)"
            echo "3. Verify SSH service: sudo systemctl status sshd"
            echo "4. Check if server has public IP: curl ifconfig.me on the server"
          fi
          
          # Adiciona o host ao known_hosts usando o SSH_HOST real
          if [ -n "${{ env.SSH_HOST }}" ]; then
            ssh-keyscan -p ${{ env.SSH_PORT }} -H "${{ env.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not add host to known_hosts, but continuing..."
            chmod 644 ~/.ssh/known_hosts
          fi

      - name: Copy files to EC2
        run: |
          # Teste de conex√£o SSH antes de continuar
          echo "Testing SSH connection to ${{ env.SSH_HOST }}:${{ env.SSH_PORT }}..."
          
          # Verificar se o config existe e testar conex√£o
          SSH_CONFIG_PATH="$HOME/.ssh/config"
          SSH_CONNECTION_FAILED=false
          
          if [ -f "$SSH_CONFIG_PATH" ]; then
            echo "‚úÖ SSH config encontrado. Testando conex√£o..."
            ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} "echo 'SSH connection successful'" || SSH_CONNECTION_FAILED=true
          else
            echo "‚ö†Ô∏è  SSH config n√£o encontrado, usando m√©todo alternativo..."
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "echo 'SSH connection successful'" || SSH_CONNECTION_FAILED=true
          fi
          
          if [ "$SSH_CONNECTION_FAILED" = true ]; then
            echo ""
            echo "‚ùå ERROR: Cannot connect to ${{ env.SSH_HOST }}:${{ env.SSH_PORT }}"
            echo ""
            echo "The connection is timing out. This means the IP is reachable but port ${{ env.SSH_PORT }} is blocked or not responding."
            echo ""
            echo "üîç Most likely causes:"
            echo ""
            echo "1. AWS Security Group blocking port 22"
            echo "   ‚Üí Go to EC2 Console ‚Üí Security Groups ‚Üí Select your instance's security group"
            echo "   ‚Üí Add Inbound Rule: Type=SSH, Port=22, Source=0.0.0.0/0 (or GitHub Actions IPs)"
            echo ""
            echo "2. Server firewall blocking port 22"
            echo "   ‚Üí SSH to the server (if you have another way) and run:"
            echo "     sudo ufw allow 22/tcp"
            echo "     sudo ufw reload"
            echo "   ‚Üí Or check iptables: sudo iptables -L -n"
            echo ""
            echo "3. SSH service not running"
            echo "   ‚Üí On the server, check: sudo systemctl status sshd"
            echo "   ‚Üí Start if needed: sudo systemctl start sshd"
            echo ""
            echo "4. Server in private subnet"
            echo "   ‚Üí If server is in a private subnet, you need a bastion host"
            echo "   ‚Üí Or assign a public IP to the instance"
            echo ""
            echo "5. Wrong SSH port"
            echo "   ‚Üí If SSH is on a different port, set SSH_PORT variable in GitHub"
            echo ""
            echo "Current configuration:"
            echo "  SSH_HOST: ${{ env.SSH_HOST }}"
            echo "  SSH_PORT: ${{ env.SSH_PORT }}"
            echo "  SSH_USER: ${{ env.SSH_USER }}"
            echo ""
            echo "üí° Quick test from your local machine:"
            echo "   ssh -v ${{ env.SSH_USER }}@${{ env.SSH_HOST }} -p ${{ env.SSH_PORT }}"
            exit 1
          fi
          
          echo "‚úÖ SSH connection successful!"
          
          # Instalar rsync no servidor se n√£o estiver instalado
          echo "Verificando se rsync est√° instalado no servidor..."
          INSTALL_RSYNC_SCRIPT="
          if ! command -v rsync &> /dev/null; then
            echo 'Instalando rsync...'
            if command -v yum &> /dev/null; then
              sudo yum install -y rsync
            elif command -v apt-get &> /dev/null; then
              sudo apt-get update && sudo apt-get install -y rsync
            else
              echo '‚ùå ERROR: N√£o foi poss√≠vel determinar o gerenciador de pacotes (yum/apt-get)'
              exit 1
            fi
          else
            echo '‚úÖ rsync j√° est√° instalado'
          fi
          "
          
          if [ -f "$SSH_CONFIG_PATH" ]; then
            ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} "$INSTALL_RSYNC_SCRIPT"
          else
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "$INSTALL_RSYNC_SCRIPT"
          fi
          
          # Limpar diret√≥rio antigo (opcional - mant√©m backup)
          echo "Criando backup do diret√≥rio antigo..."
          if [ -f "$SSH_CONFIG_PATH" ]; then
            ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} \
              "sudo mkdir -p ${{ env.APP_DIR }}.backup && sudo cp -r ${{ env.APP_DIR }}/* ${{ env.APP_DIR }}.backup/ 2>/dev/null || true"
          else
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} \
              "sudo mkdir -p ${{ env.APP_DIR }}.backup && sudo cp -r ${{ env.APP_DIR }}/* ${{ env.APP_DIR }}.backup/ 2>/dev/null || true"
          fi
          
          # Verificar se a pasta dist existe antes de fazer rsync
          if [ ! -d "./dist/avaliador_de_herois" ]; then
            echo "‚ùå ERROR: Pasta dist/avaliador_de_herois n√£o encontrada!"
            echo "O build pode ter falhado ou o outputPath est√° incorreto."
            exit 1
          fi
          
          # Verificar se h√° arquivos na pasta dist
          if [ -z "$(ls -A ./dist/avaliador_de_herois)" ]; then
            echo "‚ùå ERROR: Pasta dist/avaliador_de_herois est√° vazia!"
            exit 1
          fi
          
          echo "‚úÖ Pasta dist encontrada com arquivos. Iniciando c√≥pia..."
          
          # Preparar comando rsync com m√©todo que funcionou na conex√£o
          RSYNC_SUCCESS=false
          
          if [ -f "$SSH_CONFIG_PATH" ]; then
            echo "Usando SSH config para rsync..."
            if rsync -avz -e "ssh -F $SSH_CONFIG_PATH" \
              --delete \
              ./dist/avaliador_de_herois/ ${{ env.FRONTEND_HOST }}:/tmp/app/ 2>&1; then
              RSYNC_SUCCESS=true
            else
              RSYNC_EXIT_CODE=$?
              echo "‚ö†Ô∏è  rsync com config falhou (exit code: $RSYNC_EXIT_CODE), tentando m√©todo alternativo..."
            fi
          fi
          
          # Se n√£o conseguiu com config, usar m√©todo alternativo
          if [ "$RSYNC_SUCCESS" = false ]; then
            echo "Usando m√©todo alternativo para rsync..."
            if rsync -avz -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }}" \
              --delete \
              ./dist/avaliador_de_herois/ ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/app/ 2>&1; then
              RSYNC_SUCCESS=true
            else
              RSYNC_EXIT_CODE=$?
              echo "‚ùå rsync com m√©todo alternativo tamb√©m falhou (exit code: $RSYNC_EXIT_CODE)"
            fi
          fi
          
          # Verificar se o rsync foi bem-sucedido
          if [ "$RSYNC_SUCCESS" = false ]; then
            echo "‚ùå ERROR: rsync falhou ao copiar arquivos!"
            echo "Tentando m√©todo alternativo com tar + scp..."
            
            # M√©todo alternativo: criar tar e copiar via scp
            echo "Criando arquivo tar..."
            cd dist && tar czf avaliador_de_herois.tar.gz avaliador_de_herois/ && cd ..
            
            # Copiar via scp
            if [ -f "$SSH_CONFIG_PATH" ]; then
              scp -F "$SSH_CONFIG_PATH" ./dist/avaliador_de_herois.tar.gz ${{ env.FRONTEND_HOST }}:/tmp/app.tar.gz
            else
              scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P ${{ env.SSH_PORT }} ./dist/avaliador_de_herois.tar.gz ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/app.tar.gz
            fi
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Arquivo tar copiado com sucesso. Descompactando no servidor..."
              
              # Descompactar no servidor
              EXTRACT_SCRIPT="
              sudo mkdir -p /tmp/app
              sudo rm -rf /tmp/app/*
              cd /tmp && sudo tar xzf app.tar.gz -C /tmp/app --strip-components=1
              sudo rm -f /tmp/app.tar.gz
              echo '‚úÖ Arquivos descompactados com sucesso'
              "
              
              if [ -f "$SSH_CONFIG_PATH" ]; then
                ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} "$EXTRACT_SCRIPT"
              else
                ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "$EXTRACT_SCRIPT"
              fi
              
              if [ $? -eq 0 ]; then
                echo "‚úÖ Arquivos copiados para /tmp/app no servidor (m√©todo alternativo)"
                rm -f ./dist/avaliador_de_herois.tar.gz
              else
                echo "‚ùå ERROR: Falha ao descompactar arquivos no servidor!"
                exit 1
              fi
            else
              echo "‚ùå ERROR: Falha ao copiar arquivo tar via scp!"
              exit 1
            fi
          else
            echo "‚úÖ Arquivos copiados para /tmp/app no servidor (via rsync)"
          fi

      - name: Move files and set permissions
        run: |
          # Determinar qual m√©todo SSH usar (o mesmo que funcionou no step anterior)
          SSH_CONFIG_PATH="$HOME/.ssh/config"
          
          # Script a ser executado no servidor
          SERVER_SCRIPT="
          # Verificar se /tmp/app existe e tem arquivos
          if [ ! -d \"/tmp/app\" ] || [ -z \"\$(ls -A /tmp/app)\" ]; then
            echo \"‚ùå ERROR: /tmp/app n√£o existe ou est√° vazio!\"
            exit 1
          fi
          
          echo \"‚úÖ /tmp/app encontrado. Movendo arquivos para ${{ env.APP_DIR }}...\"
          
          # Criar diret√≥rio se n√£o existir
          sudo mkdir -p ${{ env.APP_DIR }}
          
          # Limpar diret√≥rio antigo
          sudo rm -rf ${{ env.APP_DIR }}/*
          
          # Mover arquivos
          sudo mv /tmp/app/* ${{ env.APP_DIR }}/
          
          # Verificar se a movimenta√ß√£o foi bem-sucedida
          if [ -z \"\$(ls -A ${{ env.APP_DIR }})\" ]; then
            echo \"‚ùå ERROR: Nenhum arquivo foi movido para ${{ env.APP_DIR }}!\"
            exit 1
          fi
          
          echo \"‚úÖ Arquivos movidos com sucesso. Configurando permiss√µes...\"
          
          # Configurar permiss√µes
          sudo chown -R nginx:nginx ${{ env.APP_DIR }}
          sudo chmod -R 755 ${{ env.APP_DIR }}
          
          echo \"‚úÖ Permiss√µes configuradas. Recarregando nginx...\"
          sudo systemctl reload nginx
          
          echo \"‚úÖ Deploy conclu√≠do com sucesso!\"
          "
          
          # Executar script no servidor usando m√©todo que funcionou
          if [ -f "$SSH_CONFIG_PATH" ]; then
            ssh -F "$SSH_CONFIG_PATH" ${{ env.FRONTEND_HOST }} "$SERVER_SCRIPT"
          else
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "$SERVER_SCRIPT"
          fi

      - name: Health check
        run: |
          sleep 5
          curl -f http://${{ env.FRONTEND_HOST }} || exit 0  # N√£o falha se ainda n√£o estiver acess√≠vel

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key
